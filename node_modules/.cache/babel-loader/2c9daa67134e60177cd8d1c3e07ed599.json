{"ast":null,"code":"'use strict';\n\nvar support = require('./support');\n\nvar compressions = require('./compressions');\n\nvar nodeBuffer = require('./nodeBuffer');\n/**\n * Convert a string to a \"binary string\" : a string containing only char codes between 0 and 255.\n * @param {string} str the string to transform.\n * @return {String} the binary string.\n */\n\n\nexports.string2binary = function (str) {\n  var result = \"\";\n\n  for (var i = 0; i < str.length; i++) {\n    result += String.fromCharCode(str.charCodeAt(i) & 0xff);\n  }\n\n  return result;\n};\n\nexports.arrayBuffer2Blob = function (buffer) {\n  exports.checkSupport(\"blob\");\n\n  try {\n    // Blob constructor\n    return new Blob([buffer], {\n      type: \"application/zip\"\n    });\n  } catch (e) {\n    try {\n      // deprecated, browser only, old way\n      var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n      var builder = new Builder();\n      builder.append(buffer);\n      return builder.getBlob('application/zip');\n    } catch (e) {\n      // well, fuck ?!\n      throw new Error(\"Bug : can't construct the Blob.\");\n    }\n  }\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */\n\n\nfunction identity(input) {\n  return input;\n}\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */\n\n\nfunction stringToArrayLike(str, array) {\n  for (var i = 0; i < str.length; ++i) {\n    array[i] = str.charCodeAt(i) & 0xFF;\n  }\n\n  return array;\n}\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */\n\n\nfunction arrayLikeToString(array) {\n  // Performances notes :\n  // --------------------\n  // String.fromCharCode.apply(null, array) is the fastest, see\n  // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n  // but the stack is limited (and we can get huge arrays !).\n  //\n  // result += String.fromCharCode(array[i]); generate too many strings !\n  //\n  // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n  var chunk = 65536;\n  var result = [],\n      len = array.length,\n      type = exports.getTypeOf(array),\n      k = 0,\n      canUseApply = true;\n\n  try {\n    switch (type) {\n      case \"uint8array\":\n        String.fromCharCode.apply(null, new Uint8Array(0));\n        break;\n\n      case \"nodebuffer\":\n        String.fromCharCode.apply(null, nodeBuffer(0));\n        break;\n    }\n  } catch (e) {\n    canUseApply = false;\n  } // no apply : slow and painful algorithm\n  // default browser on android 4.*\n\n\n  if (!canUseApply) {\n    var resultStr = \"\";\n\n    for (var i = 0; i < array.length; i++) {\n      resultStr += String.fromCharCode(array[i]);\n    }\n\n    return resultStr;\n  }\n\n  while (k < len && chunk > 1) {\n    try {\n      if (type === \"array\" || type === \"nodebuffer\") {\n        result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n      } else {\n        result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n      }\n\n      k += chunk;\n    } catch (e) {\n      chunk = Math.floor(chunk / 2);\n    }\n  }\n\n  return result.join(\"\");\n}\n\nexports.applyFromCharCode = arrayLikeToString;\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */\n\nfunction arrayLikeToArrayLike(arrayFrom, arrayTo) {\n  for (var i = 0; i < arrayFrom.length; i++) {\n    arrayTo[i] = arrayFrom[i];\n  }\n\n  return arrayTo;\n} // a matrix containing functions to transform everything into everything.\n\n\nvar transform = {}; // string to ?\n\ntransform[\"string\"] = {\n  \"string\": identity,\n  \"array\": function (input) {\n    return stringToArrayLike(input, new Array(input.length));\n  },\n  \"arraybuffer\": function (input) {\n    return transform[\"string\"][\"uint8array\"](input).buffer;\n  },\n  \"uint8array\": function (input) {\n    return stringToArrayLike(input, new Uint8Array(input.length));\n  },\n  \"nodebuffer\": function (input) {\n    return stringToArrayLike(input, nodeBuffer(input.length));\n  }\n}; // array to ?\n\ntransform[\"array\"] = {\n  \"string\": arrayLikeToString,\n  \"array\": identity,\n  \"arraybuffer\": function (input) {\n    return new Uint8Array(input).buffer;\n  },\n  \"uint8array\": function (input) {\n    return new Uint8Array(input);\n  },\n  \"nodebuffer\": function (input) {\n    return nodeBuffer(input);\n  }\n}; // arraybuffer to ?\n\ntransform[\"arraybuffer\"] = {\n  \"string\": function (input) {\n    return arrayLikeToString(new Uint8Array(input));\n  },\n  \"array\": function (input) {\n    return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n  },\n  \"arraybuffer\": identity,\n  \"uint8array\": function (input) {\n    return new Uint8Array(input);\n  },\n  \"nodebuffer\": function (input) {\n    return nodeBuffer(new Uint8Array(input));\n  }\n}; // uint8array to ?\n\ntransform[\"uint8array\"] = {\n  \"string\": arrayLikeToString,\n  \"array\": function (input) {\n    return arrayLikeToArrayLike(input, new Array(input.length));\n  },\n  \"arraybuffer\": function (input) {\n    return input.buffer;\n  },\n  \"uint8array\": identity,\n  \"nodebuffer\": function (input) {\n    return nodeBuffer(input);\n  }\n}; // nodebuffer to ?\n\ntransform[\"nodebuffer\"] = {\n  \"string\": arrayLikeToString,\n  \"array\": function (input) {\n    return arrayLikeToArrayLike(input, new Array(input.length));\n  },\n  \"arraybuffer\": function (input) {\n    return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n  },\n  \"uint8array\": function (input) {\n    return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n  },\n  \"nodebuffer\": identity\n};\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */\n\nexports.transformTo = function (outputType, input) {\n  if (!input) {\n    // undefined, null, etc\n    // an empty string won't harm.\n    input = \"\";\n  }\n\n  if (!outputType) {\n    return input;\n  }\n\n  exports.checkSupport(outputType);\n  var inputType = exports.getTypeOf(input);\n  var result = transform[inputType][outputType](input);\n  return result;\n};\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */\n\n\nexports.getTypeOf = function (input) {\n  if (typeof input === \"string\") {\n    return \"string\";\n  }\n\n  if (Object.prototype.toString.call(input) === \"[object Array]\") {\n    return \"array\";\n  }\n\n  if (support.nodebuffer && nodeBuffer.test(input)) {\n    return \"nodebuffer\";\n  }\n\n  if (support.uint8array && input instanceof Uint8Array) {\n    return \"uint8array\";\n  }\n\n  if (support.arraybuffer && input instanceof ArrayBuffer) {\n    return \"arraybuffer\";\n  }\n};\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */\n\n\nexports.checkSupport = function (type) {\n  var supported = support[type.toLowerCase()];\n\n  if (!supported) {\n    throw new Error(type + \" is not supported by this browser\");\n  }\n};\n\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */\n\nexports.pretty = function (str) {\n  var res = '',\n      code,\n      i;\n\n  for (i = 0; i < (str || \"\").length; i++) {\n    code = str.charCodeAt(i);\n    res += '\\\\x' + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n  }\n\n  return res;\n};\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */\n\n\nexports.findCompression = function (compressionMethod) {\n  for (var method in compressions) {\n    if (!compressions.hasOwnProperty(method)) {\n      continue;\n    }\n\n    if (compressions[method].magic === compressionMethod) {\n      return compressions[method];\n    }\n  }\n\n  return null;\n};\n/**\n* Cross-window, cross-Node-context regular expression detection\n* @param  {Object}  object Anything\n* @return {Boolean}        true if the object is a regular expression,\n* false otherwise\n*/\n\n\nexports.isRegExp = function (object) {\n  return Object.prototype.toString.call(object) === \"[object RegExp]\";\n};","map":{"version":3,"names":["support","require","compressions","nodeBuffer","exports","string2binary","str","result","i","length","String","fromCharCode","charCodeAt","arrayBuffer2Blob","buffer","checkSupport","Blob","type","e","Builder","window","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","builder","append","getBlob","Error","identity","input","stringToArrayLike","array","arrayLikeToString","chunk","len","getTypeOf","k","canUseApply","apply","Uint8Array","resultStr","push","slice","Math","min","subarray","floor","join","applyFromCharCode","arrayLikeToArrayLike","arrayFrom","arrayTo","transform","Array","byteLength","transformTo","outputType","inputType","Object","prototype","toString","call","nodebuffer","test","uint8array","arraybuffer","ArrayBuffer","supported","toLowerCase","MAX_VALUE_16BITS","MAX_VALUE_32BITS","pretty","res","code","toUpperCase","findCompression","compressionMethod","method","hasOwnProperty","magic","isRegExp","object"],"sources":["/Users/contactaisoft/Documents/GitHub/REACT_LANGUAGE/tcsmgmt/node_modules/jszip/lib/utils.js"],"sourcesContent":["'use strict';\nvar support = require('./support');\nvar compressions = require('./compressions');\nvar nodeBuffer = require('./nodeBuffer');\n/**\n * Convert a string to a \"binary string\" : a string containing only char codes between 0 and 255.\n * @param {string} str the string to transform.\n * @return {String} the binary string.\n */\nexports.string2binary = function(str) {\n    var result = \"\";\n    for (var i = 0; i < str.length; i++) {\n        result += String.fromCharCode(str.charCodeAt(i) & 0xff);\n    }\n    return result;\n};\nexports.arrayBuffer2Blob = function(buffer) {\n    exports.checkSupport(\"blob\");\n\n    try {\n        // Blob constructor\n        return new Blob([buffer], {\n            type: \"application/zip\"\n        });\n    }\n    catch (e) {\n\n        try {\n            // deprecated, browser only, old way\n            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(buffer);\n            return builder.getBlob('application/zip');\n        }\n        catch (e) {\n\n            // well, fuck ?!\n            throw new Error(\"Bug : can't construct the Blob.\");\n        }\n    }\n\n\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */\nfunction identity(input) {\n    return input;\n}\n\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */\nfunction stringToArrayLike(str, array) {\n    for (var i = 0; i < str.length; ++i) {\n        array[i] = str.charCodeAt(i) & 0xFF;\n    }\n    return array;\n}\n\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */\nfunction arrayLikeToString(array) {\n    // Performances notes :\n    // --------------------\n    // String.fromCharCode.apply(null, array) is the fastest, see\n    // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n    // but the stack is limited (and we can get huge arrays !).\n    //\n    // result += String.fromCharCode(array[i]); generate too many strings !\n    //\n    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n    var chunk = 65536;\n    var result = [],\n        len = array.length,\n        type = exports.getTypeOf(array),\n        k = 0,\n        canUseApply = true;\n      try {\n         switch(type) {\n            case \"uint8array\":\n               String.fromCharCode.apply(null, new Uint8Array(0));\n               break;\n            case \"nodebuffer\":\n               String.fromCharCode.apply(null, nodeBuffer(0));\n               break;\n         }\n      } catch(e) {\n         canUseApply = false;\n      }\n\n      // no apply : slow and painful algorithm\n      // default browser on android 4.*\n      if (!canUseApply) {\n         var resultStr = \"\";\n         for(var i = 0; i < array.length;i++) {\n            resultStr += String.fromCharCode(array[i]);\n         }\n    return resultStr;\n    }\n    while (k < len && chunk > 1) {\n        try {\n            if (type === \"array\" || type === \"nodebuffer\") {\n                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n            }\n            else {\n                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n            }\n            k += chunk;\n        }\n        catch (e) {\n            chunk = Math.floor(chunk / 2);\n        }\n    }\n    return result.join(\"\");\n}\n\nexports.applyFromCharCode = arrayLikeToString;\n\n\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */\nfunction arrayLikeToArrayLike(arrayFrom, arrayTo) {\n    for (var i = 0; i < arrayFrom.length; i++) {\n        arrayTo[i] = arrayFrom[i];\n    }\n    return arrayTo;\n}\n\n// a matrix containing functions to transform everything into everything.\nvar transform = {};\n\n// string to ?\ntransform[\"string\"] = {\n    \"string\": identity,\n    \"array\": function(input) {\n        return stringToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"string\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return stringToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": function(input) {\n        return stringToArrayLike(input, nodeBuffer(input.length));\n    }\n};\n\n// array to ?\ntransform[\"array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": identity,\n    \"arraybuffer\": function(input) {\n        return (new Uint8Array(input)).buffer;\n    },\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodeBuffer(input);\n    }\n};\n\n// arraybuffer to ?\ntransform[\"arraybuffer\"] = {\n    \"string\": function(input) {\n        return arrayLikeToString(new Uint8Array(input));\n    },\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n    },\n    \"arraybuffer\": identity,\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodeBuffer(new Uint8Array(input));\n    }\n};\n\n// uint8array to ?\ntransform[\"uint8array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return input.buffer;\n    },\n    \"uint8array\": identity,\n    \"nodebuffer\": function(input) {\n        return nodeBuffer(input);\n    }\n};\n\n// nodebuffer to ?\ntransform[\"nodebuffer\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": identity\n};\n\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */\nexports.transformTo = function(outputType, input) {\n    if (!input) {\n        // undefined, null, etc\n        // an empty string won't harm.\n        input = \"\";\n    }\n    if (!outputType) {\n        return input;\n    }\n    exports.checkSupport(outputType);\n    var inputType = exports.getTypeOf(input);\n    var result = transform[inputType][outputType](input);\n    return result;\n};\n\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */\nexports.getTypeOf = function(input) {\n    if (typeof input === \"string\") {\n        return \"string\";\n    }\n    if (Object.prototype.toString.call(input) === \"[object Array]\") {\n        return \"array\";\n    }\n    if (support.nodebuffer && nodeBuffer.test(input)) {\n        return \"nodebuffer\";\n    }\n    if (support.uint8array && input instanceof Uint8Array) {\n        return \"uint8array\";\n    }\n    if (support.arraybuffer && input instanceof ArrayBuffer) {\n        return \"arraybuffer\";\n    }\n};\n\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */\nexports.checkSupport = function(type) {\n    var supported = support[type.toLowerCase()];\n    if (!supported) {\n        throw new Error(type + \" is not supported by this browser\");\n    }\n};\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */\nexports.pretty = function(str) {\n    var res = '',\n        code, i;\n    for (i = 0; i < (str || \"\").length; i++) {\n        code = str.charCodeAt(i);\n        res += '\\\\x' + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n    }\n    return res;\n};\n\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */\nexports.findCompression = function(compressionMethod) {\n    for (var method in compressions) {\n        if (!compressions.hasOwnProperty(method)) {\n            continue;\n        }\n        if (compressions[method].magic === compressionMethod) {\n            return compressions[method];\n        }\n    }\n    return null;\n};\n/**\n* Cross-window, cross-Node-context regular expression detection\n* @param  {Object}  object Anything\n* @return {Boolean}        true if the object is a regular expression,\n* false otherwise\n*/\nexports.isRegExp = function (object) {\n    return Object.prototype.toString.call(object) === \"[object RegExp]\";\n};\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}