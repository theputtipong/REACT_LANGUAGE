{"ast":null,"code":"'use strict';\n\nvar utils = require('./utils');\n\nvar support = require('./support');\n\nvar nodeBuffer = require('./nodeBuffer');\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\n\n\nvar _utf8len = new Array(256);\n\nfor (var i = 0; i < 256; i++) {\n  _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;\n}\n\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n// convert string to array (typed, when possible)\n\nvar string2buf = function (str) {\n  var buf,\n      c,\n      c2,\n      m_pos,\n      i,\n      str_len = str.length,\n      buf_len = 0; // count binary size\n\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n\n    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n      c2 = str.charCodeAt(m_pos + 1);\n\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  } // allocate buffer\n\n\n  if (support.uint8array) {\n    buf = new Uint8Array(buf_len);\n  } else {\n    buf = new Array(buf_len);\n  } // convert\n\n\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n\n    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n      c2 = str.charCodeAt(m_pos + 1);\n\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | c >>> 6;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | c >>> 12;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | c >>> 18;\n      buf[i++] = 0x80 | c >>> 12 & 0x3f;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    }\n  }\n\n  return buf;\n}; // Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\n\n\nvar utf8border = function (buf, max) {\n  var pos;\n  max = max || buf.length;\n\n  if (max > buf.length) {\n    max = buf.length;\n  } // go back from last position, until start of sequence found\n\n\n  pos = max - 1;\n\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {\n    pos--;\n  } // Fuckup - very small and broken sequence,\n  // return max, because we should return something anyway.\n\n\n  if (pos < 0) {\n    return max;\n  } // If we came to start of buffer - that means vuffer is too small,\n  // return max too.\n\n\n  if (pos === 0) {\n    return max;\n  }\n\n  return pos + _utf8len[buf[pos]] > max ? pos : max;\n}; // convert array to string\n\n\nvar buf2string = function (buf) {\n  var str, i, out, c, c_len;\n  var len = buf.length; // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++]; // quick process ascii\n\n    if (c < 0x80) {\n      utf16buf[out++] = c;\n      continue;\n    }\n\n    c_len = _utf8len[c]; // skip 5 & 6 byte codes\n\n    if (c_len > 4) {\n      utf16buf[out++] = 0xfffd;\n      i += c_len - 1;\n      continue;\n    } // apply mask on first byte\n\n\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07; // join the rest\n\n    while (c_len > 1 && i < len) {\n      c = c << 6 | buf[i++] & 0x3f;\n      c_len--;\n    } // terminated by end of string?\n\n\n    if (c_len > 1) {\n      utf16buf[out++] = 0xfffd;\n      continue;\n    }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;\n      utf16buf[out++] = 0xdc00 | c & 0x3ff;\n    }\n  } // shrinkBuf(utf16buf, out)\n\n\n  if (utf16buf.length !== out) {\n    if (utf16buf.subarray) {\n      utf16buf = utf16buf.subarray(0, out);\n    } else {\n      utf16buf.length = out;\n    }\n  } // return String.fromCharCode.apply(null, utf16buf);\n\n\n  return utils.applyFromCharCode(utf16buf);\n}; // That's all for the pako functions.\n\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */\n\n\nexports.utf8encode = function utf8encode(str) {\n  if (support.nodebuffer) {\n    return nodeBuffer(str, \"utf-8\");\n  }\n\n  return string2buf(str);\n};\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */\n\n\nexports.utf8decode = function utf8decode(buf) {\n  if (support.nodebuffer) {\n    return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n  }\n\n  buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf); // return buf2string(buf);\n  // Chrome prefers to work with \"small\" chunks of data\n  // for the method buf2string.\n  // Firefox and Chrome has their own shortcut, IE doesn't seem to really care.\n\n  var result = [],\n      k = 0,\n      len = buf.length,\n      chunk = 65536;\n\n  while (k < len) {\n    var nextBoundary = utf8border(buf, Math.min(k + chunk, len));\n\n    if (support.uint8array) {\n      result.push(buf2string(buf.subarray(k, nextBoundary)));\n    } else {\n      result.push(buf2string(buf.slice(k, nextBoundary)));\n    }\n\n    k = nextBoundary;\n  }\n\n  return result.join(\"\");\n}; // vim: set shiftwidth=4 softtabstop=4:","map":{"version":3,"names":["utils","require","support","nodeBuffer","_utf8len","Array","i","string2buf","str","buf","c","c2","m_pos","str_len","length","buf_len","charCodeAt","uint8array","Uint8Array","utf8border","max","pos","buf2string","out","c_len","len","utf16buf","subarray","applyFromCharCode","exports","utf8encode","nodebuffer","utf8decode","transformTo","toString","result","k","chunk","nextBoundary","Math","min","push","slice","join"],"sources":["/Users/contactaisoft/Documents/GitHub/REACT_LANGUAGE/tcsmgmt/node_modules/jszip/lib/utf8.js"],"sourcesContent":["'use strict';\n\nvar utils = require('./utils');\nvar support = require('./support');\nvar nodeBuffer = require('./nodeBuffer');\n\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new Array(256);\nfor (var i=0; i<256; i++) {\n  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);\n}\n_utf8len[254]=_utf8len[254]=1; // Invalid sequence start\n\n// convert string to array (typed, when possible)\nvar string2buf = function (str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n    // count binary size\n    for (m_pos = 0; m_pos < str_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n\n    // allocate buffer\n    if (support.uint8array) {\n        buf = new Uint8Array(buf_len);\n    } else {\n        buf = new Array(buf_len);\n    }\n\n    // convert\n    for (i=0, m_pos = 0; i < buf_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */\n            buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */\n            buf[i++] = 0xC0 | (c >>> 6);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else if (c < 0x10000) {\n            /* three bytes */\n            buf[i++] = 0xE0 | (c >>> 12);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else {\n            /* four bytes */\n            buf[i++] = 0xf0 | (c >>> 18);\n            buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        }\n    }\n\n    return buf;\n};\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = function(buf, max) {\n    var pos;\n\n    max = max || buf.length;\n    if (max > buf.length) { max = buf.length; }\n\n    // go back from last position, until start of sequence found\n    pos = max-1;\n    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n    // Fuckup - very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) { return max; }\n\n    // If we came to start of buffer - that means vuffer is too small,\n    // return max too.\n    if (pos === 0) { return max; }\n\n    return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n// convert array to string\nvar buf2string = function (buf) {\n    var str, i, out, c, c_len;\n    var len = buf.length;\n\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len*2);\n\n    for (out=0, i=0; i<len;) {\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }\n\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while (c_len > 1 && i < len) {\n            c = (c << 6) | (buf[i++] & 0x3f);\n            c_len--;\n        }\n\n        // terminated by end of string?\n        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n            utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n        }\n    }\n\n    // shrinkBuf(utf16buf, out)\n    if (utf16buf.length !== out) {\n        if(utf16buf.subarray) {\n            utf16buf = utf16buf.subarray(0, out);\n        } else {\n            utf16buf.length = out;\n        }\n    }\n\n    // return String.fromCharCode.apply(null, utf16buf);\n    return utils.applyFromCharCode(utf16buf);\n};\n\n\n// That's all for the pako functions.\n\n\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */\nexports.utf8encode = function utf8encode(str) {\n    if (support.nodebuffer) {\n        return nodeBuffer(str, \"utf-8\");\n    }\n\n    return string2buf(str);\n};\n\n\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */\nexports.utf8decode = function utf8decode(buf) {\n    if (support.nodebuffer) {\n        return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n    }\n\n    buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n\n    // return buf2string(buf);\n    // Chrome prefers to work with \"small\" chunks of data\n    // for the method buf2string.\n    // Firefox and Chrome has their own shortcut, IE doesn't seem to really care.\n    var result = [], k = 0, len = buf.length, chunk = 65536;\n    while (k < len) {\n        var nextBoundary = utf8border(buf, Math.min(k + chunk, len));\n        if (support.uint8array) {\n            result.push(buf2string(buf.subarray(k, nextBoundary)));\n        } else {\n            result.push(buf2string(buf.slice(k, nextBoundary)));\n        }\n        k = nextBoundary;\n    }\n    return result.join(\"\");\n\n};\n// vim: set shiftwidth=4 softtabstop=4:\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}